{"version":3,"file":"static/js/996.d296d78e.chunk.js","mappings":"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","sources":["../../../packages/ra-data-graphql/src/introspection.ts","../../../packages/ra-data-graphql/src/constants.ts","../../../packages/ra-data-graphql/src/index.ts","../../../packages/ra-data-graphql/src/buildApolloClient.ts","../../../packages/ra-data-graphql-simple/src/getFinalType.ts","../../../packages/ra-data-graphql-simple/src/isList.ts","../../../packages/ra-data-graphql-simple/src/buildVariables.ts","../../../packages/ra-data-graphql-simple/src/isRequired.ts","../../../packages/ra-data-graphql-simple/src/buildGqlQuery.ts","../../../packages/ra-data-graphql-simple/src/getResponseParser.ts","../../../packages/ra-data-graphql-simple/src/buildQuery.ts","../../../packages/ra-data-graphql-simple/src/index.ts","dataProvider/graphql.ts","../../../packages/ra-core/src/dataProvider/HttpError.ts"],"sourcesContent":["import {\n    getIntrospectionQuery,\n    IntrospectionObjectType,\n    IntrospectionQuery,\n    IntrospectionSchema,\n    IntrospectionType,\n} from 'graphql';\nimport { ApolloClient, gql } from '@apollo/client';\n\nimport { ALL_TYPES } from './constants';\n\nlet introspectionPromise;\n\n/**\n * @param {ApolloClient} client The Apollo client\n * @param {Object} options The introspection options\n */\nexport const introspectSchema = async (\n    client: ApolloClient<unknown>,\n    options: IntrospectionOptions\n) => {\n    if (introspectionPromise) {\n        return introspectionPromise;\n    }\n    introspectionPromise = runSchemaIntrospection(client, options);\n    return introspectionPromise;\n};\n\nexport type IntrospectionOptions = {\n    schema?: IntrospectionSchema;\n    operationNames: {\n        [key: string]: (type: IntrospectionType) => string;\n    };\n    exclude?: string[] | ((type: IntrospectionType) => boolean);\n    include?: string[] | ((type: IntrospectionType) => boolean);\n};\n\nexport type IntrospectedResource = {\n    type: IntrospectionObjectType;\n};\nexport type IntrospectionResult = {\n    types: IntrospectionType[];\n    queries: IntrospectionObjectType[];\n    resources: IntrospectedResource[];\n    schema: IntrospectionSchema;\n};\n\nconst runSchemaIntrospection = async (\n    client: ApolloClient<unknown>,\n    options: IntrospectionOptions\n) => {\n    const schema = options.schema ? options.schema : await fetchSchema(client);\n    const queries = getQueriesFromSchema(schema);\n    const types = getTypesFromSchema(schema);\n    const resources = getResources(types, queries, options);\n\n    return {\n        types,\n        queries,\n        resources,\n        schema,\n    };\n};\n\nconst fetchSchema = (\n    client: ApolloClient<unknown>\n): Promise<IntrospectionSchema> => {\n    return client\n        .query<IntrospectionQuery>({\n            fetchPolicy: 'network-only',\n            query: gql`\n                ${getIntrospectionQuery()}\n            `,\n        })\n        .then(({ data: { __schema } }) => __schema);\n};\n\nconst getQueriesFromSchema = (\n    schema: IntrospectionSchema\n): IntrospectionObjectType[] => {\n    return schema.types.reduce((acc, type) => {\n        if (\n            type.name !== schema.queryType?.name &&\n            type.name !== schema.mutationType?.name &&\n            (type as IntrospectionObjectType).fields\n        ) {\n            return acc;\n        }\n\n        return [...acc, ...((type as IntrospectionObjectType).fields || [])];\n    }, []);\n};\n\nconst getTypesFromSchema = (schema: IntrospectionSchema) => {\n    return schema.types.filter(\n        type =>\n            type.name !== (schema.queryType && schema.queryType.name) &&\n            type.name !== (schema.mutationType && schema.mutationType.name)\n    );\n};\n\nconst getResources = (\n    types: IntrospectionType[],\n    queries: IntrospectionObjectType[],\n    options: IntrospectionOptions\n): IntrospectedResource[] => {\n    const filteredResources = types.filter(type =>\n        isResource(type, queries, options)\n    );\n    return filteredResources.map(type =>\n        buildResource(type as IntrospectionObjectType, queries, options)\n    );\n};\n\nconst isResource = (\n    type: IntrospectionType,\n    queries: IntrospectionObjectType[],\n    options: IntrospectionOptions\n) => {\n    if (isResourceIncluded(type, options)) return true;\n    if (isResourceExcluded(type, options)) return false;\n\n    const operations = Object.keys(options.operationNames).map(operation =>\n        options.operationNames[operation](type)\n    );\n\n    const hasAtLeastOneOperation = operations.some(operation =>\n        queries.find(({ name }) => name === operation)\n    );\n\n    return hasAtLeastOneOperation;\n};\n\nexport const isResourceIncluded = (\n    type: IntrospectionType,\n    { include }: Partial<IntrospectionOptions> = {}\n) => {\n    if (Array.isArray(include)) {\n        return include.includes(type.name);\n    }\n\n    if (typeof include === 'function') {\n        return include(type);\n    }\n\n    return false;\n};\n\nexport const isResourceExcluded = (\n    type: IntrospectionType,\n    { exclude }: Partial<IntrospectionOptions> = {}\n) => {\n    if (Array.isArray(exclude)) {\n        return exclude.includes(type.name);\n    }\n\n    if (typeof exclude === 'function') {\n        return exclude(type);\n    }\n\n    return false;\n};\n\nconst buildResource = (\n    type: IntrospectionObjectType,\n    queries: IntrospectionObjectType[],\n    options: IntrospectionOptions\n): IntrospectedResource => {\n    return ALL_TYPES.reduce(\n        (acc, raFetchMethod) => {\n            const query = queries.find(\n                ({ name }) =>\n                    options.operationNames[raFetchMethod] &&\n                    name === options.operationNames[raFetchMethod](type)\n            );\n\n            if (!query) return acc;\n\n            return {\n                ...acc,\n                [raFetchMethod]: query,\n            };\n        },\n        { type }\n    );\n};\n","import {\n    GET_LIST,\n    GET_ONE,\n    GET_MANY,\n    GET_MANY_REFERENCE,\n    CREATE,\n    UPDATE,\n    UPDATE_MANY,\n    DELETE,\n    DELETE_MANY,\n} from 'ra-core';\n\nexport const QUERY_TYPES = [GET_LIST, GET_MANY, GET_MANY_REFERENCE, GET_ONE];\nexport const MUTATION_TYPES = [\n    CREATE,\n    UPDATE,\n    DELETE,\n    UPDATE_MANY,\n    DELETE_MANY,\n];\nexport const ALL_TYPES = QUERY_TYPES.concat(MUTATION_TYPES);\n","import merge from 'lodash/merge';\nimport get from 'lodash/get';\nimport pluralize from 'pluralize';\nimport {\n    DataProvider,\n    HttpError,\n    GET_LIST,\n    GET_ONE,\n    GET_MANY,\n    GET_MANY_REFERENCE,\n    CREATE,\n    UPDATE,\n    DELETE,\n    DELETE_MANY,\n    UPDATE_MANY,\n} from 'ra-core';\nimport {\n    ApolloClient,\n    ApolloClientOptions,\n    ApolloError,\n    ApolloQueryResult,\n    MutationOptions,\n    WatchQueryOptions,\n    QueryOptions,\n    OperationVariables,\n    ServerError,\n} from '@apollo/client';\n\nimport buildApolloClient from './buildApolloClient';\nimport {\n    QUERY_TYPES as INNER_QUERY_TYPES,\n    MUTATION_TYPES as INNER_MUTATION_TYPES,\n    ALL_TYPES as INNER_ALL_TYPES,\n} from './constants';\nimport {\n    introspectSchema,\n    IntrospectionOptions,\n    IntrospectionResult,\n} from './introspection';\n\nexport * from './introspection';\nexport const QUERY_TYPES = INNER_QUERY_TYPES;\nexport const MUTATION_TYPES = INNER_MUTATION_TYPES;\nexport const ALL_TYPES = INNER_ALL_TYPES;\n\nconst RaFetchMethodMap = {\n    getList: GET_LIST,\n    getMany: GET_MANY,\n    getManyReference: GET_MANY_REFERENCE,\n    getOne: GET_ONE,\n    create: CREATE,\n    delete: DELETE,\n    deleteMany: DELETE_MANY,\n    update: UPDATE,\n    updateMany: UPDATE_MANY,\n};\nconst defaultOptions = {\n    resolveIntrospection: introspectSchema,\n    introspection: {\n        operationNames: {\n            [GET_LIST]: resource => `all${pluralize(resource.name)}`,\n            [GET_ONE]: resource => `${resource.name}`,\n            [GET_MANY]: resource => `all${pluralize(resource.name)}`,\n            [GET_MANY_REFERENCE]: resource => `all${pluralize(resource.name)}`,\n            [CREATE]: resource => `create${resource.name}`,\n            [UPDATE]: resource => `update${resource.name}`,\n            [DELETE]: resource => `delete${resource.name}`,\n        },\n        exclude: undefined,\n        include: undefined,\n    },\n};\n\nconst getOptions = (\n    options: GetQueryOptions | GetMutationOptions | GetWatchQueryOptions,\n    raFetchMethod: string,\n    resource: string\n) => {\n    if (typeof options === 'function') {\n        return options(resource, raFetchMethod);\n    }\n\n    return options;\n};\n\nexport type BuildQueryResult = QueryOptions<OperationVariables, any> & {\n    parseResponse: (response: ApolloQueryResult<any>) => any;\n};\n\nexport type BuildQuery = (\n    name: string,\n    resource: string,\n    params: any\n) => BuildQueryResult;\n\nexport type BuildQueryFactory = (\n    introspectionResults: IntrospectionResult\n) => BuildQuery;\n\nexport type GetQueryOptions = (\n    resource: string,\n    raFetchMethod: string\n) => Partial<QueryOptions<OperationVariables, any>>;\n\nexport type GetMutationOptions = (\n    resource: string,\n    raFetchMethod: string\n) => Partial<MutationOptions<OperationVariables, any>>;\n\nexport type GetWatchQueryOptions = (\n    resource: string,\n    raFetchMethod: string\n) => Partial<WatchQueryOptions<OperationVariables, any>>;\n\nexport type Options = {\n    client?: ApolloClient<unknown>;\n    clientOptions?: Partial<ApolloClientOptions<unknown>>;\n    introspection?: false | Partial<IntrospectionOptions>;\n    override?: {\n        [key: string]: (params: any) => BuildQueryResult;\n    };\n    buildQuery: BuildQueryFactory;\n    query?: GetQueryOptions;\n    mutation?: GetMutationOptions;\n    watchQuery?: GetWatchQueryOptions;\n};\n\nexport default async (options: Options): Promise<DataProvider> => {\n    const {\n        client: clientObject,\n        clientOptions,\n        introspection,\n        resolveIntrospection,\n        buildQuery: buildQueryFactory,\n        override = {},\n        ...otherOptions\n    } = merge({}, defaultOptions, options);\n\n    if (override && process.env.NODE_ENV === 'production') {\n        console.warn(\n            // eslint-disable-line\n            'The override option is deprecated. You should instead wrap the buildQuery function provided by the dataProvider you use.'\n        );\n    }\n\n    const client = clientObject || buildApolloClient(clientOptions);\n\n    let introspectionResults;\n\n    const raDataProvider = new Proxy<DataProvider>(defaultDataProvider, {\n        get: (target, name) => {\n            if (typeof name === 'symbol' || name === 'then') {\n                return;\n            }\n            const raFetchMethod = RaFetchMethodMap[name];\n            return async (resource, params) => {\n                if (introspection) {\n                    introspectionResults = await resolveIntrospection(\n                        client,\n                        introspection\n                    );\n                }\n\n                const buildQuery = buildQueryFactory(introspectionResults);\n                const overriddenBuildQuery = get(\n                    override,\n                    `${resource}.${raFetchMethod}`\n                );\n\n                const { parseResponse, ...query } = overriddenBuildQuery\n                    ? {\n                          ...buildQuery(raFetchMethod, resource, params),\n                          ...overriddenBuildQuery(params),\n                      }\n                    : buildQuery(raFetchMethod, resource, params);\n\n                const operation = getQueryOperation(query.query);\n\n                if (operation === 'query') {\n                    const apolloQuery = {\n                        ...query,\n                        fetchPolicy: 'network-only',\n                        ...getOptions(\n                            otherOptions.query,\n                            raFetchMethod,\n                            resource\n                        ),\n                    };\n\n                    return (\n                        client\n                            // @ts-ignore\n                            .query(apolloQuery)\n                            .then(response => parseResponse(response))\n                            .catch(handleError)\n                    );\n                }\n\n                const apolloQuery = {\n                    mutation: query.query,\n                    variables: query.variables,\n                    ...getOptions(\n                        otherOptions.mutation,\n                        raFetchMethod,\n                        resource\n                    ),\n                };\n\n                return (\n                    client\n                        // @ts-ignore\n                        .mutate(apolloQuery)\n                        .then(parseResponse)\n                        .catch(handleError)\n                );\n            };\n        },\n    });\n\n    return raDataProvider;\n};\n\nconst handleError = (error: ApolloError) => {\n    if (error?.networkError as ServerError) {\n        throw new HttpError(\n            (error?.networkError as ServerError)?.message,\n            (error?.networkError as ServerError)?.statusCode\n        );\n    }\n\n    throw new HttpError(error.message, 200, error);\n};\n\nconst getQueryOperation = query => {\n    if (query && query.definitions && query.definitions.length > 0) {\n        return query.definitions[0].operation;\n    }\n\n    throw new Error('Unable to determine the query operation');\n};\n\n// Only used to initialize proxy\nconst defaultDataProvider = {\n    create: () => Promise.resolve({ data: null }), // avoids adding a context in tests\n    delete: () => Promise.resolve({ data: null }), // avoids adding a context in tests\n    deleteMany: () => Promise.resolve({ data: [] }), // avoids adding a context in tests\n    getList: () => Promise.resolve({ data: [], total: 0 }), // avoids adding a context in tests\n    getMany: () => Promise.resolve({ data: [] }), // avoids adding a context in tests\n    getManyReference: () => Promise.resolve({ data: [], total: 0 }), // avoids adding a context in tests\n    getOne: () => Promise.resolve({ data: null }), // avoids adding a context in tests\n    update: () => Promise.resolve({ data: null }), // avoids adding a context in tests\n    updateMany: () => Promise.resolve({ data: [] }), // avoids adding a context in tests\n};\n","import {\n    ApolloClient,\n    ApolloClientOptions,\n    HttpLink,\n    InMemoryCache,\n} from '@apollo/client';\n\nexport default (options: Partial<ApolloClientOptions<unknown>>) => {\n    if (!options) {\n        return new ApolloClient({\n            cache: new InMemoryCache().restore({}),\n        });\n    }\n\n    const {\n        cache = new InMemoryCache().restore({}),\n        uri,\n        link = !!uri ? new HttpLink({ uri }) : undefined,\n        ...otherOptions\n    } = options;\n\n    return new ApolloClient({\n        link,\n        cache,\n        ...otherOptions,\n    });\n};\n","import {\n    IntrospectionType,\n    IntrospectionTypeRef,\n    IntrospectionNonNullTypeRef,\n    TypeKind,\n} from 'graphql';\n\n/**\n * Ensure we get the real type even if the root type is NON_NULL or LIST\n * @param {GraphQLType} type\n */\nconst getFinalType = (\n    type: IntrospectionType | IntrospectionNonNullTypeRef | IntrospectionTypeRef\n) => {\n    if (type.kind === TypeKind.NON_NULL || type.kind === TypeKind.LIST) {\n        return getFinalType(type.ofType);\n    }\n\n    return type;\n};\n\nexport default getFinalType;\n","import {\n    IntrospectionType,\n    IntrospectionTypeRef,\n    IntrospectionNonNullTypeRef,\n    TypeKind,\n} from 'graphql';\n\nconst isList = (\n    type: IntrospectionType | IntrospectionNonNullTypeRef | IntrospectionTypeRef\n) => {\n    if (type.kind === TypeKind.NON_NULL) {\n        return isList(type.ofType);\n    }\n\n    return type.kind === TypeKind.LIST;\n};\n\nexport default isList;\n","/* eslint-disable default-case */\nimport {\n    IntrospectionField,\n    IntrospectionInputObjectType,\n    IntrospectionNamedTypeRef,\n    IntrospectionNonNullTypeRef,\n    IntrospectionType,\n} from 'graphql';\nimport {\n    GET_LIST,\n    GET_ONE,\n    GET_MANY,\n    GET_MANY_REFERENCE,\n    CREATE,\n    UPDATE,\n    DELETE,\n} from 'ra-core';\nimport { IntrospectionResult, IntrospectedResource } from 'ra-data-graphql';\n\nimport getFinalType from './getFinalType';\nimport isList from './isList';\n\nexport default (introspectionResults: IntrospectionResult) => (\n    resource: IntrospectedResource,\n    raFetchMethod: string,\n    params: any,\n    queryType: IntrospectionField\n) => {\n    const preparedParams = prepareParams(\n        params,\n        queryType,\n        introspectionResults\n    );\n\n    switch (raFetchMethod) {\n        case GET_LIST: {\n            return buildGetListVariables(introspectionResults)(\n                resource,\n                raFetchMethod,\n                preparedParams\n            );\n        }\n        case GET_MANY:\n            return {\n                filter: { ids: preparedParams.ids },\n            };\n        case GET_MANY_REFERENCE: {\n            let variables = buildGetListVariables(introspectionResults)(\n                resource,\n                raFetchMethod,\n                preparedParams\n            );\n\n            variables.filter = {\n                ...variables.filter,\n                [preparedParams.target]: preparedParams.id,\n            };\n\n            return variables;\n        }\n        case GET_ONE:\n        case DELETE:\n            return {\n                id: preparedParams.id,\n            };\n        case CREATE:\n        case UPDATE: {\n            return buildCreateUpdateVariables(\n                resource,\n                raFetchMethod,\n                preparedParams,\n                queryType\n            );\n        }\n    }\n};\n\nconst sanitizeValue = (type: IntrospectionType, value: any) => {\n    if (type.name === 'Int') {\n        return parseInt(value, 10);\n    }\n\n    if (type.name === 'Float') {\n        return parseFloat(value);\n    }\n\n    return value;\n};\n\nconst castType = (\n    value: any,\n    type: IntrospectionType | IntrospectionNonNullTypeRef\n) => {\n    const realType = type.kind === 'NON_NULL' ? type.ofType : type;\n    switch (\n        `${realType.kind}:${(realType as IntrospectionNamedTypeRef).name}`\n    ) {\n        case 'SCALAR:Int':\n            return Number(value);\n\n        case 'SCALAR:String':\n            return String(value);\n\n        case 'SCALAR:Boolean':\n            return Boolean(value);\n\n        default:\n            return value;\n    }\n};\n\nconst prepareParams = (\n    params: any,\n    queryType: Partial<IntrospectionField>,\n    introspectionResults: IntrospectionResult\n) => {\n    const result = {};\n\n    if (!params) {\n        return params;\n    }\n\n    Object.keys(params).forEach(key => {\n        const param = params[key];\n        let arg = null;\n\n        if (!param) {\n            result[key] = param;\n            return;\n        }\n\n        if (queryType && Array.isArray(queryType.args)) {\n            arg = queryType.args.find(item => item.name === key);\n        }\n\n        if (param instanceof File) {\n            result[key] = param;\n            return;\n        }\n\n        if (param instanceof Date) {\n            result[key] = param.toISOString();\n            return;\n        }\n\n        if (\n            param instanceof Object &&\n            !Array.isArray(param) &&\n            arg &&\n            arg.type.kind === 'INPUT_OBJECT'\n        ) {\n            const args = (introspectionResults.types.find(\n                item =>\n                    item.kind === arg.type.kind && item.name === arg.type.name\n            ) as IntrospectionInputObjectType).inputFields;\n            result[key] = prepareParams(param, { args }, introspectionResults);\n            return;\n        }\n\n        if (\n            param instanceof Object &&\n            !(param instanceof Date) &&\n            !Array.isArray(param)\n        ) {\n            result[key] = prepareParams(param, queryType, introspectionResults);\n            return;\n        }\n\n        if (!arg) {\n            result[key] = param;\n            return;\n        }\n\n        result[key] = castType(param, arg.type);\n    });\n\n    return result;\n};\n\nconst buildGetListVariables = (introspectionResults: IntrospectionResult) => (\n    resource: IntrospectedResource,\n    raFetchMethod: string,\n    params: any\n) => {\n    let variables: Partial<{\n        filter: { [key: string]: any };\n        page: number;\n        perPage: number;\n        sortField: string;\n        sortOrder: string;\n    }> = { filter: {} };\n    if (params.filter) {\n        variables.filter = Object.keys(params.filter).reduce((acc, key) => {\n            if (key === 'ids') {\n                return { ...acc, ids: params.filter[key] };\n            }\n\n            if (typeof params.filter[key] === 'object') {\n                const type = introspectionResults.types.find(\n                    t => t.name === `${resource.type.name}Filter`\n                );\n                const filterSome = (type as IntrospectionInputObjectType)?.inputFields?.find(\n                    t => t.name === `${key}_some`\n                );\n\n                if (filterSome) {\n                    const filter = Object.keys(params.filter[key]).reduce(\n                        (acc, k) => ({\n                            ...acc,\n                            [`${k}_in`]: params.filter[key][k],\n                        }),\n                        {}\n                    );\n                    return { ...acc, [`${key}_some`]: filter };\n                }\n            }\n\n            const parts = key.split('.');\n\n            if (parts.length > 1) {\n                if (parts[1] === 'id') {\n                    const type = introspectionResults.types.find(\n                        t => t.name === `${resource.type.name}Filter`\n                    );\n                    const filterSome = (type as IntrospectionInputObjectType)?.inputFields?.find(\n                        t => t.name === `${parts[0]}_some`\n                    );\n\n                    if (filterSome) {\n                        return {\n                            ...acc,\n                            [`${parts[0]}_some`]: { id: params.filter[key] },\n                        };\n                    }\n\n                    return { ...acc, [parts[0]]: { id: params.filter[key] } };\n                }\n\n                const resourceField = resource.type.fields.find(\n                    f => f.name === parts[0]\n                );\n                const type = getFinalType(resourceField.type);\n                return {\n                    ...acc,\n                    [key]: sanitizeValue(type, params.filter[key]),\n                };\n            }\n\n            const resourceField = resource.type.fields.find(\n                f => f.name === key\n            );\n\n            if (resourceField) {\n                const type = getFinalType(resourceField.type);\n                const isAList = isList(resourceField.type);\n\n                if (isAList) {\n                    return {\n                        ...acc,\n                        [key]: Array.isArray(params.filter[key])\n                            ? params.filter[key].map(value =>\n                                  sanitizeValue(type, value)\n                              )\n                            : sanitizeValue(type, [params.filter[key]]),\n                    };\n                }\n\n                return {\n                    ...acc,\n                    [key]: sanitizeValue(type, params.filter[key]),\n                };\n            }\n\n            return { ...acc, [key]: params.filter[key] };\n        }, {});\n    }\n\n    if (params.pagination) {\n        variables.page = parseInt(params.pagination.page, 10) - 1;\n        variables.perPage = parseInt(params.pagination.perPage, 10);\n    }\n\n    if (params.sort) {\n        variables.sortField = params.sort.field;\n        variables.sortOrder = params.sort.order;\n    }\n\n    return variables;\n};\n\nconst buildCreateUpdateVariables = (\n    resource: IntrospectedResource,\n    raFetchMethod,\n    { id, data }: any,\n    queryType: IntrospectionField\n) =>\n    Object.keys(data).reduce(\n        (acc, key) => {\n            if (Array.isArray(data[key])) {\n                const arg = queryType.args.find(a => a.name === `${key}Ids`);\n\n                if (arg) {\n                    return {\n                        ...acc,\n                        [`${key}Ids`]: data[key].map(({ id }) => id),\n                    };\n                }\n            }\n\n            if (typeof data[key] === 'object') {\n                const arg = queryType.args.find(a => a.name === `${key}Id`);\n\n                if (arg) {\n                    return {\n                        ...acc,\n                        [`${key}Id`]: data[key].id,\n                    };\n                }\n            }\n\n            return {\n                ...acc,\n                [key]: data[key],\n            };\n        },\n        { id }\n    );\n","import {\n    IntrospectionType,\n    IntrospectionListTypeRef,\n    IntrospectionTypeRef,\n    TypeKind,\n} from 'graphql';\n\nconst isRequired = (\n    type: IntrospectionType | IntrospectionListTypeRef | IntrospectionTypeRef\n) => {\n    if (type.kind === TypeKind.LIST) {\n        return isRequired(type.ofType);\n    }\n\n    return type.kind === TypeKind.NON_NULL;\n};\n\nexport default isRequired;\n","import { GET_LIST, GET_MANY, GET_MANY_REFERENCE, DELETE } from 'ra-core';\nimport {\n    QUERY_TYPES,\n    IntrospectionResult,\n    IntrospectedResource,\n} from 'ra-data-graphql';\nimport {\n    ArgumentNode,\n    IntrospectionField,\n    IntrospectionInputValue,\n    IntrospectionNamedTypeRef,\n    IntrospectionObjectType,\n    IntrospectionUnionType,\n    TypeKind,\n    TypeNode,\n    VariableDefinitionNode,\n} from 'graphql';\nimport * as gqlTypes from 'graphql-ast-types-browser';\n\nimport getFinalType from './getFinalType';\nimport isList from './isList';\nimport isRequired from './isRequired';\n\nexport default (introspectionResults: IntrospectionResult) => (\n    resource: IntrospectedResource,\n    raFetchMethod: string,\n    queryType: IntrospectionField,\n    variables: any\n) => {\n    const { sortField, sortOrder, ...metaVariables } = variables;\n    const apolloArgs = buildApolloArgs(queryType, variables);\n    const args = buildArgs(queryType, variables);\n    const metaArgs = buildArgs(queryType, metaVariables);\n    const fields = buildFields(introspectionResults)(resource.type.fields);\n\n    if (\n        raFetchMethod === GET_LIST ||\n        raFetchMethod === GET_MANY ||\n        raFetchMethod === GET_MANY_REFERENCE\n    ) {\n        return gqlTypes.document([\n            gqlTypes.operationDefinition(\n                'query',\n                gqlTypes.selectionSet([\n                    gqlTypes.field(\n                        gqlTypes.name(queryType.name),\n                        gqlTypes.name('items'),\n                        args,\n                        null,\n                        gqlTypes.selectionSet(fields)\n                    ),\n                    gqlTypes.field(\n                        gqlTypes.name(`_${queryType.name}Meta`),\n                        gqlTypes.name('total'),\n                        metaArgs,\n                        null,\n                        gqlTypes.selectionSet([\n                            gqlTypes.field(gqlTypes.name('count')),\n                        ])\n                    ),\n                ]),\n                gqlTypes.name(queryType.name),\n                apolloArgs\n            ),\n        ]);\n    }\n\n    if (raFetchMethod === DELETE) {\n        return gqlTypes.document([\n            gqlTypes.operationDefinition(\n                'mutation',\n                gqlTypes.selectionSet([\n                    gqlTypes.field(\n                        gqlTypes.name(queryType.name),\n                        gqlTypes.name('data'),\n                        args,\n                        null,\n                        gqlTypes.selectionSet(fields)\n                    ),\n                ]),\n                gqlTypes.name(queryType.name),\n                apolloArgs\n            ),\n        ]);\n    }\n\n    return gqlTypes.document([\n        gqlTypes.operationDefinition(\n            QUERY_TYPES.includes(raFetchMethod) ? 'query' : 'mutation',\n            gqlTypes.selectionSet([\n                gqlTypes.field(\n                    gqlTypes.name(queryType.name),\n                    gqlTypes.name('data'),\n                    args,\n                    null,\n                    gqlTypes.selectionSet(fields)\n                ),\n            ]),\n            gqlTypes.name(queryType.name),\n            apolloArgs\n        ),\n    ]);\n};\n\nexport const buildFields = (\n    introspectionResults: IntrospectionResult,\n    paths = []\n) => fields =>\n    fields.reduce((acc, field) => {\n        const type = getFinalType(field.type);\n\n        if (type.name.startsWith('_')) {\n            return acc;\n        }\n\n        if (type.kind !== TypeKind.OBJECT && type.kind !== TypeKind.INTERFACE) {\n            return [...acc, gqlTypes.field(gqlTypes.name(field.name))];\n        }\n\n        const linkedResource = introspectionResults.resources.find(\n            r => r.type.name === type.name\n        );\n\n        if (linkedResource) {\n            return [\n                ...acc,\n                gqlTypes.field(\n                    gqlTypes.name(field.name),\n                    null,\n                    null,\n                    null,\n                    gqlTypes.selectionSet([gqlTypes.field(gqlTypes.name('id'))])\n                ),\n            ];\n        }\n\n        const linkedType = introspectionResults.types.find(\n            t => t.name === type.name\n        );\n\n        if (linkedType && !paths.includes(linkedType.name)) {\n            const possibleTypes =\n                (linkedType as IntrospectionUnionType).possibleTypes || [];\n            return [\n                ...acc,\n                gqlTypes.field(\n                    gqlTypes.name(field.name),\n                    null,\n                    null,\n                    null,\n                    gqlTypes.selectionSet([\n                        ...buildFragments(introspectionResults)(possibleTypes),\n                        ...buildFields(introspectionResults, [\n                            ...paths,\n                            linkedType.name,\n                        ])((linkedType as IntrospectionObjectType).fields),\n                    ])\n                ),\n            ];\n        }\n\n        // NOTE: We might have to handle linked types which are not resources but will have to be careful about\n        // ending with endless circular dependencies\n        return acc;\n    }, []);\n\nexport const buildFragments = (introspectionResults: IntrospectionResult) => (\n    possibleTypes: readonly IntrospectionNamedTypeRef<IntrospectionObjectType>[]\n) =>\n    possibleTypes.reduce((acc, possibleType) => {\n        const type = getFinalType(possibleType);\n\n        const linkedType = introspectionResults.types.find(\n            t => t.name === type.name\n        );\n\n        return [\n            ...acc,\n            gqlTypes.inlineFragment(\n                gqlTypes.selectionSet(\n                    buildFields(introspectionResults)(\n                        (linkedType as IntrospectionObjectType).fields\n                    )\n                ),\n                gqlTypes.namedType(gqlTypes.name(type.name))\n            ),\n        ];\n    }, []);\n\nexport const buildArgs = (\n    query: IntrospectionField,\n    variables: any\n): ArgumentNode[] => {\n    if (query.args.length === 0) {\n        return [];\n    }\n\n    const validVariables = Object.keys(variables).filter(\n        k => typeof variables[k] !== 'undefined'\n    );\n    let args = query.args\n        .filter(a => validVariables.includes(a.name))\n        .reduce(\n            (acc, arg) => [\n                ...acc,\n                gqlTypes.argument(\n                    gqlTypes.name(arg.name),\n                    gqlTypes.variable(gqlTypes.name(arg.name))\n                ),\n            ],\n            []\n        );\n\n    return args;\n};\n\nexport const buildApolloArgs = (\n    query: IntrospectionField,\n    variables: any\n): VariableDefinitionNode[] => {\n    if (query.args.length === 0) {\n        return [];\n    }\n\n    const validVariables = Object.keys(variables).filter(\n        k => typeof variables[k] !== 'undefined'\n    );\n\n    let args = query.args\n        .filter(a => validVariables.includes(a.name))\n        .reduce((acc, arg) => {\n            return [\n                ...acc,\n                gqlTypes.variableDefinition(\n                    gqlTypes.variable(gqlTypes.name(arg.name)),\n                    getArgType(arg)\n                ),\n            ];\n        }, []);\n\n    return args;\n};\n\nexport const getArgType = (arg: IntrospectionInputValue): TypeNode => {\n    const type = getFinalType(arg.type);\n    const required = isRequired(arg.type);\n    const list = isList(arg.type);\n\n    if (list) {\n        if (required) {\n            return gqlTypes.listType(\n                gqlTypes.nonNullType(\n                    gqlTypes.namedType(gqlTypes.name(type.name))\n                )\n            );\n        }\n        return gqlTypes.listType(gqlTypes.namedType(gqlTypes.name(type.name)));\n    }\n\n    if (required) {\n        return gqlTypes.nonNullType(\n            gqlTypes.namedType(gqlTypes.name(type.name))\n        );\n    }\n\n    return gqlTypes.namedType(gqlTypes.name(type.name));\n};\n","import { GET_LIST, GET_MANY, GET_MANY_REFERENCE } from 'ra-core';\nimport { IntrospectionResult, IntrospectedResource } from 'ra-data-graphql';\nimport { IntrospectionField } from 'graphql';\nimport { ApolloQueryResult } from '@apollo/client';\n\nexport default (introspectionResults: IntrospectionResult) => (\n    raFetchMethod: string,\n    resource: IntrospectedResource,\n    queryType: IntrospectionField\n) => (response: ApolloQueryResult<any>) => {\n    const data = response.data;\n\n    if (\n        raFetchMethod === GET_LIST ||\n        raFetchMethod === GET_MANY ||\n        raFetchMethod === GET_MANY_REFERENCE\n    ) {\n        return {\n            data: response.data.items.map(sanitizeResource),\n            total: response.data.total.count,\n        };\n    }\n\n    return { data: sanitizeResource(data.data) };\n};\n\nconst sanitizeResource = (data: any) => {\n    const result = Object.keys(data).reduce((acc, key) => {\n        if (key.startsWith('_')) {\n            return acc;\n        }\n\n        const dataForKey = data[key];\n\n        if (dataForKey === null || dataForKey === undefined) {\n            return acc;\n        }\n\n        if (Array.isArray(dataForKey)) {\n            if (\n                typeof dataForKey[0] === 'object' &&\n                dataForKey[0] != null &&\n                // If there is no id, it's not a reference but an embedded array\n                dataForKey[0].id != null\n            ) {\n                return {\n                    ...acc,\n                    [key]: dataForKey.map(sanitizeResource),\n                    [`${key}Ids`]: dataForKey.map(d => d.id),\n                };\n            } else {\n                return { ...acc, [key]: dataForKey };\n            }\n        }\n\n        if (\n            typeof dataForKey === 'object' &&\n            dataForKey != null &&\n            // If there is no id, it's not a reference but an embedded object\n            dataForKey.id != null\n        ) {\n            return {\n                ...acc,\n                ...(dataForKey &&\n                    dataForKey.id && {\n                        [`${key}.id`]: dataForKey.id,\n                    }),\n                // We should only sanitize gql types, not objects\n                [key]: dataForKey.__typename\n                    ? sanitizeResource(dataForKey)\n                    : dataForKey,\n            };\n        }\n\n        return { ...acc, [key]: dataForKey };\n    }, {});\n\n    return result;\n};\n","import { IntrospectionResult, BuildQuery } from 'ra-data-graphql';\nimport buildVariables from './buildVariables';\nimport buildGqlQuery from './buildGqlQuery';\nimport getResponseParser from './getResponseParser';\n\nexport const buildQueryFactory = (\n    buildVariablesImpl = buildVariables,\n    buildGqlQueryImpl = buildGqlQuery,\n    getResponseParserImpl = getResponseParser\n) => (introspectionResults: IntrospectionResult): BuildQuery => {\n    const knownResources = introspectionResults.resources.map(r => r.type.name);\n\n    const buildQuery: BuildQuery = (raFetchType, resourceName, params) => {\n        const resource = introspectionResults.resources.find(\n            r => r.type.name === resourceName\n        );\n\n        if (!resource) {\n            throw new Error(\n                `Unknown resource ${resourceName}. Make sure it has been declared on your server side schema. Known resources are ${knownResources.join(\n                    ', '\n                )}`\n            );\n        }\n\n        const queryType = resource[raFetchType];\n\n        if (!queryType) {\n            throw new Error(\n                `No query or mutation matching fetch type ${raFetchType} could be found for resource ${resource.type.name}`\n            );\n        }\n\n        const variables = buildVariablesImpl(introspectionResults)(\n            resource,\n            raFetchType,\n            params,\n            queryType\n        );\n        const query = buildGqlQueryImpl(introspectionResults)(\n            resource,\n            raFetchType,\n            queryType,\n            variables\n        );\n        const parseResponse = getResponseParserImpl(introspectionResults)(\n            raFetchType,\n            resource,\n            queryType\n        );\n\n        return {\n            query,\n            variables,\n            parseResponse,\n        };\n    };\n\n    return buildQuery;\n};\n\nexport default buildQueryFactory(\n    buildVariables,\n    buildGqlQuery,\n    getResponseParser\n);\n","import merge from 'lodash/merge';\nimport buildDataProvider, { BuildQueryFactory, Options } from 'ra-data-graphql';\nimport { DataProvider, Identifier } from 'ra-core';\n\nimport defaultBuildQuery from './buildQuery';\nconst defaultOptions = {\n    buildQuery: defaultBuildQuery,\n};\n\nexport const buildQuery = defaultBuildQuery;\n\nexport default (\n    options: Omit<Options, 'buildQuery'> & { buildQuery?: BuildQueryFactory }\n): Promise<DataProvider> => {\n    return buildDataProvider(merge({}, defaultOptions, options)).then(\n        defaultDataProvider => {\n            return {\n                ...defaultDataProvider,\n                // This provider does not support multiple deletions so instead we send multiple DELETE requests\n                // This can be optimized using the apollo-link-batch-http link\n                deleteMany: (resource, params) => {\n                    const { ids, ...otherParams } = params;\n                    return Promise.all(\n                        ids.map(id =>\n                            defaultDataProvider.delete(resource, {\n                                id,\n                                previousData: null,\n                                ...otherParams,\n                            })\n                        )\n                    ).then(results => {\n                        const data = results.reduce<Identifier[]>(\n                            (acc, { data }) => [...acc, data.id],\n                            []\n                        );\n\n                        return { data };\n                    });\n                },\n                // This provider does not support multiple deletions so instead we send multiple UPDATE requests\n                // This can be optimized using the apollo-link-batch-http link\n                updateMany: (resource, params) => {\n                    const { ids, data, ...otherParams } = params;\n                    return Promise.all(\n                        ids.map(id =>\n                            defaultDataProvider.update(resource, {\n                                id,\n                                data: data,\n                                previousData: null,\n                                ...otherParams,\n                            })\n                        )\n                    ).then(results => {\n                        const data = results.reduce<Identifier[]>(\n                            (acc, { data }) => [...acc, data.id],\n                            []\n                        );\n\n                        return { data };\n                    });\n                },\n            };\n        }\n    );\n};\n","import { ApolloQueryResult } from '@apollo/client';\nimport buildApolloClient, {\n    buildQuery as buildQueryFactory,\n} from 'ra-data-graphql-simple';\nimport { BuildQueryFactory } from 'ra-data-graphql';\nimport { CREATE, DataProvider, DELETE } from 'react-admin';\nimport gql from 'graphql-tag';\nimport { IntrospectionType } from 'graphql';\n\nconst getGqlResource = (resource: string) => {\n    switch (resource) {\n        case 'customers':\n            return 'Customer';\n\n        case 'categories':\n            return 'Category';\n\n        case 'commands':\n            return 'Command';\n\n        case 'products':\n            return 'Product';\n\n        case 'reviews':\n            return 'Review';\n\n        case 'invoices':\n            return 'Invoice';\n\n        default:\n            throw new Error(`Unknown resource ${resource}`);\n    }\n};\n\nconst customBuildQuery: BuildQueryFactory = introspectionResults => {\n    const buildQuery = buildQueryFactory(introspectionResults);\n\n    return (type, resource, params) => {\n        if (type === DELETE) {\n            return {\n                query: gql`mutation remove${resource}($id: ID!) {\n                    remove${resource}(id: $id) {\n                        id\n                    }\n                }`,\n                variables: { id: params.id },\n                parseResponse: ({ data }: ApolloQueryResult<any>) => {\n                    if (data[`remove${resource}`]) {\n                        return { data: { id: params.id } };\n                    }\n\n                    throw new Error(`Could not delete ${resource}`);\n                },\n            };\n        }\n\n        if (resource === 'Customer' && type === CREATE) {\n            return {\n                query: gql`\n                    mutation createCustomer(\n                        $first_name: String!\n                        $last_name: String!\n                        $email: String!\n                        $address: String\n                        $zipcode: String\n                        $city: String\n                        $stateAbbr: String\n                        $birthday: Date\n                        $first_seen: Date!\n                        $last_seen: Date!\n                        $has_ordered: Boolean!\n                        $latest_purchase: Date\n                        $has_newsletter: Boolean!\n                        $groups: [String]!\n                        $nb_commands: Int!\n                        $total_spent: Float!\n                    ) {\n                        createCustomer(\n                            first_name: $first_name\n                            last_name: $last_name\n                            email: $email\n                            address: $address\n                            zipcode: $zipcode\n                            city: $city\n                            stateAbbr: $stateAbbr\n                            birthday: $birthday\n                            first_seen: $first_seen\n                            last_seen: $last_seen\n                            has_ordered: $has_ordered\n                            latest_purchase: $latest_purchase\n                            has_newsletter: $has_newsletter\n                            groups: $groups\n                            nb_commands: $nb_commands\n                            total_spent: $total_spent\n                        ) {\n                            id\n                        }\n                    }\n                `,\n                variables: params.data,\n                parseResponse: ({ data }: ApolloQueryResult<any>) => {\n                    if (data.createCustomer) {\n                        return { data: { id: data.createCustomer.id } };\n                    }\n\n                    throw new Error(`Could not create Customer`);\n                },\n            };\n        }\n\n        return buildQuery(type, resource, params);\n    };\n};\n\nexport default async () => {\n    const dataProvider = await buildApolloClient({\n        clientOptions: {\n            uri: 'http://localhost:4000/graphql',\n        },\n        introspection: {\n            operationNames: {\n                [DELETE]: (resource: IntrospectionType) =>\n                    `remove${resource.name}`,\n            },\n        },\n        buildQuery: customBuildQuery,\n    });\n\n    return new Proxy<DataProvider>(defaultDataProvider, {\n        get: (target, name) => {\n            if (typeof name === 'symbol' || name === 'then') {\n                return;\n            }\n            return async (resource: string, params: any) => {\n                return dataProvider[name](getGqlResource(resource), params);\n            };\n        },\n    });\n};\n// Only used to initialize proxy\nconst defaultDataProvider: DataProvider = {\n    create: () => Promise.reject({ data: null }), // avoids adding a context in tests\n    delete: () => Promise.reject({ data: null }), // avoids adding a context in tests\n    deleteMany: () => Promise.resolve({ data: [] }), // avoids adding a context in tests\n    getList: () => Promise.resolve({ data: [], total: 0 }), // avoids adding a context in tests\n    getMany: () => Promise.resolve({ data: [] }), // avoids adding a context in tests\n    getManyReference: () => Promise.resolve({ data: [], total: 0 }), // avoids adding a context in tests\n    getOne: () => Promise.reject({ data: null }), // avoids adding a context in tests\n    update: () => Promise.reject({ data: null }), // avoids adding a context in tests\n    updateMany: () => Promise.resolve({ data: [] }), // avoids adding a context in tests\n};\n","class HttpError extends Error {\n    constructor(\n        public readonly message,\n        public readonly status,\n        public readonly body = null\n    ) {\n        super(message);\n        Object.setPrototypeOf(this, HttpError.prototype);\n        this.name = this.constructor.name;\n        if (typeof Error.captureStackTrace === 'function') {\n            Error.captureStackTrace(this, this.constructor);\n        } else {\n            this.stack = new Error(message).stack;\n        }\n        this.stack = new Error().stack;\n    }\n}\n\nexport default HttpError;\n"],"names":["introspectionPromise","QUERY_TYPES","MUTATION_TYPES","ALL_TYPES","concat","runSchemaIntrospection","client","options","schema","fetchSchema","queries","getQueriesFromSchema","types","getTypesFromSchema","resources","getResources","query","fetchPolicy","getIntrospectionQuery","then","reduce","acc","type","name","queryType","mutationType","fields","filter","isResource","map","buildResource","isResourceIncluded","isResourceExcluded","hasAtLeastOneOperation","Object","keys","operationNames","operation","some","find","include","Array","isArray","includes","exclude","raFetchMethod","RaFetchMethodMap","getList","getMany","getManyReference","getOne","create","delete","deleteMany","update","updateMany","defaultOptions","resolveIntrospection","introspectSchema","introspection","resource","undefined","getOptions","clientObject","clientOptions","buildQueryFactory","override","otherOptions","console","warn","ApolloClient","cache","restore","uri","link","HttpLink","buildApolloClient","raDataProvider","Proxy","defaultDataProvider","get","target","params","introspectionResults","buildQuery","overriddenBuildQuery","parseResponse","getQueryOperation","response","catch","handleError","apolloQuery","mutation","variables","mutate","error","networkError","HttpError","message","statusCode","definitions","length","Error","Promise","resolve","data","total","getFinalType","kind","ofType","isList","preparedParams","prepareParams","buildGetListVariables","ids","id","buildCreateUpdateVariables","sanitizeValue","value","parseInt","parseFloat","result","forEach","key","param","arg","args","item","File","Date","toISOString","inputFields","castType","realType","Number","String","Boolean","filterSome","t","k","parts","split","f","resourceField","isAList","pagination","page","perPage","sort","sortField","field","sortOrder","order","a","isRequired","metaVariables","apolloArgs","buildApolloArgs","buildArgs","metaArgs","buildFields","paths","startsWith","r","linkedType","possibleTypes","buildFragments","possibleType","validVariables","getArgType","required","items","sanitizeResource","count","dataForKey","d","__typename","buildVariablesImpl","buildGqlQueryImpl","getResponseParserImpl","buildVariables","buildGqlQuery","getResponseParser","knownResources","raFetchType","resourceName","join","getGqlResource","customBuildQuery","DELETE","gql","CREATE","createCustomer","otherParams","all","previousData","results","dataProvider","reject","status","body","setPrototypeOf","prototype","constructor","captureStackTrace","stack"],"sourceRoot":""}